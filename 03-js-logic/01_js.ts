/*
1. Напишите функцию deepEqual для проверки двух обьектов на идентичность. Пример:

deepEqual({name: 'test'}, {name: 'test'}) // output true
deepEqual({name: 'test'}, {name: 'test1'}) // output false
deepEqual({name: 'test', data: {value: 1}}, {name: 'test', data: {value: 2}}) // output false
deepEqual({name: 'test'}, {name: 'test', age: 10}) // false
*/

/* ******************************************************* */
// SOLUTION

// оголошуємо стрілкову функцію та типізуємо її параметри і результат виконання
const deepEqual = (obj1: object, obj2: object): boolean => {
  //1. перевіряємо ідентичність об'єктів, порівнюючи довжину їх властивостей
  // отримуємо масив властивостей першого об'єкту
  const keys1 = Object.keys(obj1);
  // отримуємо масив властивостей другого об'єкту
  const keys2 = Object.keys(obj2);
  /* 
  порівнюємо довжину масиву властивостей першого об'єкту з
  довжиною масиву властивостей другого об'єкту за допомогою властивості length
  об'єкту Array.
  Якщо довжини масивів різні, припиняємо подальше виконання функції за допомогою
  оператора return і повертаємо false
  Немає сенсу далі перівнювати об'єкти, оскільки вже на цьому етапі зрозуміло,
  що вони не ідентичні
  */
  if (keys1.length !== keys2.length) {
    return false;
  }

  // 2. Пишемо функціонал перевірки об'єктів по значенню їх властивостей

  /* 
  Нам потрібно почергово отримувати значення з першого та другого об'єків 
  та порівнювати їх значення. Для почергового отримання значень ми скористаємося циклом.
  При цьому, для доступу до значень властивостей скористаємося масивом властивостей (keys1). 
  та дужковою нотацією []. 
  Ми знаємо, що значенням властивості об'єкта може бути інший об'єкт. 
  У такому випадку просте порівняння значень за їх вмістом не дасть потрібного результату,
  оскільки в JS об'єкти зберігаються в пам'яті по посиланню (reference), а не за їхнім вмістом.
  Отже, якщо виявиться, що якесь із значень властивості є об'єктом, то потрібно перевірити не посиланя на цей об'єкт, 
  а його внутрішні властивості та значення цих властивостей.
  Одним із способів реалізації такої переірки є рекурсія - тобто, виклик цієї ж функції (deepEqual) для
  конкретних значень, які виявилися об'єктами.
  Отже, будемо перевіряти, чи є в отриманих вище масивах (value1 та value2) значення з типом "object".
  Для цього скористаємося функцією-helper isObject().
  */

  for (const key of keys1) {
    // почергово отримуємо значення властивостей першого об'єкту
    const value1 = obj1[key];
    // почергово отримуємо значення властивостей другого об'єкту
    const value2 = obj2[key];
    // Перевіряємо чи є значення об'єктами
    const areObjects = isObject(value1) && isObject(value2);

    /* Змінна areObject може мати два значення: true або false.
    Якщо true:
       - значить поточні значення value1 та value2 є об'єктами;
       - рекурсивно викликаємо функцію deepEqual() для цих значень
         та порівнюємо ці значення
    Якщо false:
       - значить поточні значення value1 та value2 не є об'єктами
       - робимо просте порівняння цих значень 
  */
    if (
      (areObjects && !deepEqual(value1, value2)) ||
      (!areObjects && value1 !== value2)
    ) {
      return false;
    }
  }

  // якщо на попередніх етапах функція не повернула false
  // значить, об'єкти ідентичні, тому повертаємо true
  return true;
};

const isObject = (value: object): boolean => {
  return typeof value === 'object' && value !== null;
};

const auto1 = {
  brand: 'Mazda',
  engine: {
    value: 2.5,
    power: 150,
  },
};
const auto2 = {
  brand: 'Mazda',
  engine: {
    value: 2.5,
    power: 150,
  },
};

const res = deepEqual(auto1, auto2);
console.log(res);
