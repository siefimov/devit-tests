/*
8. Напишите функцию combos, которая принимает положительное целое число num и возвращает массив массивов положительных целых чисел, где сумма каждого массива равна  num.  Массивы не должны повторяться.

Пример:
combos(3);
Output: 
[
  [ 3 ],
  [ 1, 1, 1 ],
  [ 1, 2 ] 
]
*/

/* ******************************************************* */
// SOLUTION

/* 
Оголошуємо стрілкову функцію combos з одним параметром типу number
*/
const combos = (num: number) => {
  // оголошуємо змінну results, яка буде масивом масивів чисел.
  // У цьому масиві будуть зберігатися всі знайдені комбінації.
  const results: number[][] = [];
  /*
  оголошуємо внутрішню рекурсивну функцію generateCombinations(), 
  яка відповідає за фактичну генерацію комбінацій.
  функція generateCombinations приймає три обов'язкових параметри:
  - target: цей параметр представляє залишкову суму, яку ми намагаємося досягнути. 
            Під час виклику generateCombos, ми перевіряємо, чи target дорівнює 0. 
            Якщо це так, це означає, що ми знайшли комбінацію чисел, сума яких дорівнює 
            цільовій сумі, і ми додаємо цю комбінацію до результатів: results.push([...currentCombo]);
  - currentCombo: цей параметр є масивом, який представляє поточну комбінацію чисел. 
            Під час виклику функції generateCombos, числа додаються до цього масиву, 
            щоб утворити комбінацію. 
  - start: цей параметр вказує, з якого числа ми починаємо спробувати генерувати комбінації. 
           Під час першого виклику generateCombos, start зазвичай дорівнює 1, оскільки ми 
           починаємо генерувати комбінації з першого числа. У наступних викликах 
           generateCombos, start оновлюється, щоб спробувати інші числа.
  */
  const generateCombinations = (
    target: number,
    currentCombo: number[],
    start: number
  ) => {
    if (target === 0) {
      results.push([...currentCombo]);
      return;
    }
    /* 
    Ми використовуємо цикл for, щоб спробувати всі можливі числа від start до target. 
    Для кожного числа i, ми виконуємо наступні дії:
    - currentCombo.push(i): Додаємо поточне число i до комбінації currentCombo.
    - generateCombinations(target - i, currentCombo, i): Рекурсивно викликаємо generateCombinations, 
      змінюючи цільову суму target на target - i, комбінацію currentCombo з новим числом i, 
      і починаючи з start рівним i. Це означає, що ми спробуємо знайти комбінації чисел, включаючи поточне число i.
    - currentCombo.pop(): після завершення рекурсивного виклику, ми видаляємо останнє додане число `i` 
      з комбінації currentCombo. Це для того, щоб "повернутися назад" і спробувати інші комбінації.
    */
    for (let i = start; i <= target; i++) {
      currentCombo.push(i);
      generateCombinations(target - i, currentCombo, i);
      currentCombo.pop();
    }
  };

  // виклиаємо функцію generateCombinations()
  generateCombinations(num, [], 1);

  return results;
};

console.log(combos(10));
