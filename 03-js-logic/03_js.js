/* 
3. Напишите функцию обертку, которая на вход принимает массив функций и их параметров, а возвращает массив результатов их выполнения. Количество аргументов исполняемой функции не ограничено!

Пример:
const f1 = (cb) => {cb(1)}
const f2 = (a, cb) => {cb(a)}
const f3 = (a, b, cb) => {setTimeout(() => cb([a, b]), 1000)}

bulkRun(
  [
    [f1, []],
    [f2, [2]]
    [f3, [3, 4]]
  ]
).then(console.log)
 Output: [1, 2, [3, 4]]
*/

/* ******************************************************* */
// SOLUTION

// Оголошуємо стрілкову функцію, яка приймає один параметр - масив
const bulkRun = (functions) => {
  // оголошуємо змінну results, початковим значенням якої є пустий масив.
  // надалі в цей масив буде додаватися результат викоеання функцій.
  const results = [];

  // Створюємо Promise для асинхронного виконання функцій
  return new Promise((resolve, reject) => {
    // Оголошуємо функцію execute() для виконання однієї пари функція-аргументи
    const execute = ([func, args]) => {
      // Запускаємо функцію з аргументами
      func(...args, (result) => {
        // Додаємо результат в масив results
        results.push(result);

        // Якщо всі функції виконані, резолвимо Promise з results
        if (results.length === functions.length) {
          resolve(results);
        }
      });
    };

    // Проходимося циклом по масиву functions і кожен елемент ммису пропускамо
    // через функцію excute()
    functions.forEach(execute);
  });
};

// Приклади функцій
const f1 = (cb) => {
  cb(1);
};

const f2 = (a, cb) => {
  cb(a);
};

const f3 = (a, b, cb) => {
  setTimeout(() => cb([a, b]), 1000);
};

// Викликаємо bulkRun з масивом функцій та їх параметрами
bulkRun([
  [f1, []],
  [f2, [2]],
  [f3, [3, 4]],
]).then(console.log); // Виводимо результат в консоль
